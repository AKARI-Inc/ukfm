
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Attitude Estimation with an IMU - Example</title><meta name="generator" content="MATLAB 9.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-09-23"><meta name="DC.source" content="main_attitude.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Attitude Estimation with an IMU - Example</h1><!--introduction--><p>Goals of this script</p><div><ul><li>applying the UKF for estimating 3D attitude from an IMU.</li></ul></div><p><i>We assume the reader is already familiar with the tutorial.</i></p><p>Attitude estimation with an Inertial Measurement Unit (IMU). The filter fuses measurements comming from gyro, accelerometer and magnetometer. The IMU does not have any bias. We reproduce the simulation with the parameters based on [KHSchon17].</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Initialization</a></li><li><a href="#2">Simulation</a></li><li><a href="#4">Filter Design and Initialization</a></li><li><a href="#5">Filtering</a></li><li><a href="#6">Results</a></li><li><a href="#8">Conclusion</a></li></ul></div><h2 id="1">Initialization</h2><p>Start by cleaning the workspace.</p><pre class="codeinput">clear <span class="string">all</span>;
close <span class="string">all</span>;
</pre><h2 id="2">Simulation</h2><p>The true trajectory is computed along with noisy inputs after we define the noise standard deviation affecting the (accurate) IMU, where the platform is 2 s stationary and then have constant angular velocity around gravity.</p><pre class="codeinput"><span class="comment">% sequence time (s)</span>
T = 100;
<span class="comment">% IMU frequency (Hz)</span>
imu_freq = 100;
<span class="comment">% IMU standard-deviation noise (noise is isotropic)</span>
imu_noise_std = [5/180*pi; <span class="comment">% gyro (rad/s)</span>
                0.4;       <span class="comment">% accelerometer (m/s^2)</span>
                0.2];      <span class="comment">% magnetometer</span>

<span class="comment">% total number of timestamps</span>
N = T*imu_freq;
<span class="comment">% time between succesive timestamps (s)</span>
dt = 1/imu_freq;

<span class="comment">% simulate true trajectory and noised input</span>
[states, omegas] = attitude_simu_f(T, imu_freq, imu_noise_std);
<span class="comment">% simulate accelerometer and magnetometer measurements</span>
ys = attitude_simu_h(states, T, imu_freq, imu_noise_std);
</pre><p>The state and the input contain the following variables:</p><pre class="language-matlab">states(n).Rot  <span class="comment">% 3d orientation (matrix)</span>
omegas(n).gyro <span class="comment">% robot angular velocities</span>
</pre><p>A measurement ys(:, k) contains accelerometer and magnetometer measurement.</p><h2 id="4">Filter Design and Initialization</h2><p>We choose in this example to embed the state in <img src="main_attitude_eq17232210486186811875.png" alt="$SO(3)$"> with left multiplication, such that:</p><div><ul><li>the retraction <img src="main_attitude_eq17465938644384765962.png" alt="$\varphi(.,.)$"> is the <img src="main_attitude_eq17232210486186811875.png" alt="$SO(3)$"> exponential map for   orientation where the state multiplies the uncertainty on the left.</li></ul></div><div><ul><li>the inverse retraction <img src="main_attitude_eq03493348614921386861.png" alt="$\varphi^{-1}(.,.)$"> is the <img src="main_attitude_eq17232210486186811875.png" alt="$SO(3)$">   logarithm for orientation.</li></ul></div><pre class="codeinput"><span class="comment">% propagation noise matrix</span>
ukf_Q = imu_noise_std(1).^2*eye(3);
<span class="comment">% measurement noise matrix</span>
ukf_R = blkdiag(imu_noise_std(2).^2*eye(3), imu_noise_std(3).^2*eye(3));
<span class="comment">% initial error matrix</span>
ukf_P0 = zeros(3, 3); <span class="comment">% The state is perfectly initialized</span>
<span class="comment">% sigma point parameters</span>
ukf_alpha = [1e-3, 1e-3, 1e-3];

<span class="comment">% asses UKF function</span>
ukf_f = @attitude_f;
ukf_h = @attitude_h;
ukf_phi = @attitude_phi;
ukf_phi_inv = @attitude_phi_inv;
ukf_weights = ukf_set_weight(length(ukf_P0), length(ukf_R), ukf_alpha);
ukf_cholQ = chol(ukf_Q);

<span class="comment">% initialize with true state</span>
ukf_state = states(1);
ukf_P = ukf_P0;

<span class="comment">% variables for recording estimates</span>
ukf_states = ukf_state;
ukf_Ps = zeros(N, 3, 3);
ukf_Ps(1, :, :) = ukf_P;
</pre><h2 id="5">Filtering</h2><p>The UKF proceeds as a standard Kalman filter with a simple for loop.</p><pre class="codeinput"><span class="keyword">for</span> n = 2:N
    <span class="comment">% propagation</span>
    [ukf_state, ukf_P] = ukf_propagation(ukf_state, ukf_P, omegas(n-1), <span class="keyword">...</span>
        ukf_f, dt, ukf_phi, ukf_phi_inv, ukf_cholQ, ukf_weights);
    <span class="comment">% update</span>
   [ukf_state, ukf_P] = ukf_update(ukf_state, ukf_P, ys(:, n), ukf_h, <span class="keyword">...</span>
       ukf_phi, ukf_R, ukf_weights);
    <span class="comment">% save estimates</span>
    ukf_states(n) = ukf_state;
    ukf_Ps(n, :, :) = ukf_P;
<span class="keyword">end</span>
</pre><h2 id="6">Results</h2><p>We plot the orientation as function of time along with the orientation error.</p><pre class="codeinput">attitude_results_plot(ukf_states, ukf_Ps, states, omegas, dt)
</pre><img vspace="5" hspace="5" src="main_attitude_01.png" alt=""> <img vspace="5" hspace="5" src="main_attitude_02.png" alt=""> <img vspace="5" hspace="5" src="main_attitude_03.png" alt=""> <img vspace="5" hspace="5" src="main_attitude_04.png" alt=""> <p>We see the true trajectory starts by a small stationary step following by constantly turning around the gravity vector (only the yaw is increasing). As yaw is not observable with an accelerometer only, it is expected that yaw error would be stronger than roll or pitch errors.</p><p>As UKF estimates the covariance of the error, we have plotted the 95% confident interval (<img src="main_attitude_eq09036583483978579715.png" alt="$3\sigma$">). We expect the error keeps behind this interval, and in this situation the filter covariance output matches especially well the error.</p><p>A cruel aspect of these curves is the absence of comparision. Is the filter good ? It would be nice to compare it, e.g., to an extended Kalman filter.</p><h2 id="8">Conclusion</h2><p>We have seen in this script how well works the UKF on parallelizable manifolds for estimating orientation from an IMU.</p><p>You can now:</p><div><ul><li>address the UKF for the same problem with different noise parameters.</li></ul></div><div><ul><li>add outliers in acceleration or magnetometer measurements.</li></ul></div><div><ul><li>benchmark the UKF with different function errors and compare it to the   extended Kalman filter in the benchmarks folder.</li></ul></div><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Attitude Estimation with an IMU - Example
% Goals of this script
% 
% * applying the UKF for estimating 3D attitude from an IMU.
%
% _We assume the reader is already familiar with the tutorial._
%
% Attitude estimation with an Inertial Measurement Unit (IMU). The filter
% fuses measurements comming from gyro, accelerometer and magnetometer. The
% IMU does not have any bias. We reproduce the simulation with the
% parameters based on [KHSchon17].

%% Initialization 
% Start by cleaning the workspace.
clear all;
close all;

%% Simulation
% The true trajectory is computed along with noisy inputs after we define
% the noise standard deviation affecting the (accurate) IMU, where the
% platform is 2 s stationary and then have constant angular velocity around
% gravity.

% sequence time (s)
T = 100; 
% IMU frequency (Hz)
imu_freq = 100; 
% IMU standard-deviation noise (noise is isotropic)
imu_noise_std = [5/180*pi; % gyro (rad/s)
                0.4;       % accelerometer (m/s^2)
                0.2];      % magnetometer
            
% total number of timestamps
N = T*imu_freq;
% time between succesive timestamps (s)
dt = 1/imu_freq;

% simulate true trajectory and noised input
[states, omegas] = attitude_simu_f(T, imu_freq, imu_noise_std);
% simulate accelerometer and magnetometer measurements
ys = attitude_simu_h(states, T, imu_freq, imu_noise_std);         
%%
% The state and the input contain the following variables:
%
%   states(n).Rot  % 3d orientation (matrix)
%   omegas(n).gyro % robot angular velocities 
%
% A measurement ys(:, k) contains accelerometer and magnetometer
% measurement.

%% Filter Design and Initialization
% We choose in this example to embed the state in $SO(3)$ with left
% multiplication, such that:
%
% * the retraction $\varphi(.,.)$ is the $SO(3)$ exponential map for
%   orientation where the state multiplies the uncertainty on the left.
%
% * the inverse retraction $\varphi^{-1}(.,.)$ is the $SO(3)$
%   logarithm for orientation.

% propagation noise matrix
ukf_Q = imu_noise_std(1).^2*eye(3);
% measurement noise matrix
ukf_R = blkdiag(imu_noise_std(2).^2*eye(3), imu_noise_std(3).^2*eye(3));
% initial error matrix
ukf_P0 = zeros(3, 3); % The state is perfectly initialized
% sigma point parameters
ukf_alpha = [1e-3, 1e-3, 1e-3];

% asses UKF function
ukf_f = @attitude_f;
ukf_h = @attitude_h;
ukf_phi = @attitude_phi;
ukf_phi_inv = @attitude_phi_inv;
ukf_weights = ukf_set_weight(length(ukf_P0), length(ukf_R), ukf_alpha);
ukf_cholQ = chol(ukf_Q);

% initialize with true state
ukf_state = states(1);
ukf_P = ukf_P0;

% variables for recording estimates
ukf_states = ukf_state;
ukf_Ps = zeros(N, 3, 3);
ukf_Ps(1, :, :) = ukf_P;

%% Filtering
% The UKF proceeds as a standard Kalman filter with a simple for loop.
for n = 2:N
    % propagation
    [ukf_state, ukf_P] = ukf_propagation(ukf_state, ukf_P, omegas(n-1), ...
        ukf_f, dt, ukf_phi, ukf_phi_inv, ukf_cholQ, ukf_weights);
    % update
   [ukf_state, ukf_P] = ukf_update(ukf_state, ukf_P, ys(:, n), ukf_h, ...
       ukf_phi, ukf_R, ukf_weights);
    % save estimates
    ukf_states(n) = ukf_state;
    ukf_Ps(n, :, :) = ukf_P;
end

%% Results
% We plot the orientation as function of time along with the orientation
% error.
attitude_results_plot(ukf_states, ukf_Ps, states, omegas, dt)

%%
% We see the true trajectory starts by a small stationary step following by
% constantly turning around the gravity vector (only the yaw is
% increasing). As yaw is not observable with an accelerometer only, it is
% expected that yaw error would be stronger than roll or pitch errors.
%
% As UKF estimates the covariance of the error, we have plotted the 95%
% confident interval ($3\sigma$). We expect the error keeps behind this
% interval, and in this situation the filter covariance output matches
% especially well the error.
%
% A cruel aspect of these curves is the absence of comparision. Is the
% filter good ? It would be nice to compare it, e.g., to an extended Kalman
% filter.

%% Conclusion
% We have seen in this script how well works the UKF on parallelizable
% manifolds for estimating orientation from an IMU.
%
% You can now:
%
% * address the UKF for the same problem with different noise parameters.
% 
% * add outliers in acceleration or magnetometer measurements.
%
% * benchmark the UKF with different function errors and compare it to the
%   extended Kalman filter in the benchmarks folder.
##### SOURCE END #####
--></body></html>