
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Benchmark of Navigation on Flat Earth Example</title><meta name="generator" content="MATLAB 9.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-08-29"><meta name="DC.source" content="benchmark_inertial_navigation.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Benchmark of Navigation on Flat Earth Example</h1><!--introduction--><p>Goals of this script</p><div><ul><li>implement different UKFs on the navigation on flat Earth example</li><li>design the Extended Kalman Filter (EKF) and the Invariant Extended   Kalman Filter (IEKF) [1] for the given problem</li><li>compare the different algorithms with Monte-Carlo simulations</li></ul></div><p><i>We assume the reader is already familiar with the considered problem described in the example folder.</i></p><p>For the given, three different UKFs emerge, defined respectively as:</p><p>1- The state is embedded in <span class="MathJax_Preview"><img src="benchmark_inertial_navigation_eq06216273096441296132.png" alt="$SO(3) \times R^6$"></span><script type="math/tex">SO(3) \times R^6</script>, i.e.</p><div><ul><li>the function <span class="MathJax_Preview"><img src="benchmark_inertial_navigation_eq17465938644384765962.png" alt="$\varphi(.,.)$"></span><script type="math/tex">\varphi(.,.)</script> is the <span class="MathJax_Preview"><img src="benchmark_inertial_navigation_eq17232210486186811875.png" alt="$SO(3)$"></span><script type="math/tex">SO(3)</script> error for orientation, and  the standard vector addition for robot position</li><li>the function <span class="MathJax_Preview"><img src="benchmark_inertial_navigation_eq18327439109141017227.png" alt="$\varphi^{-1}$"></span><script type="math/tex">\varphi^{-1}</script> is the <span class="MathJax_Preview"><img src="benchmark_inertial_navigation_eq17232210486186811875.png" alt="$SO(3)$"></span><script type="math/tex">SO(3)</script> logarithm for orientation  and the standard vector substraction for position</li><li>it is the standard UKF</li></ul></div><p>2- The state is embedded in <span class="MathJax_Preview"><img src="benchmark_inertial_navigation_eq02895149905820079520.png" alt="$SE_2(3)$"></span><script type="math/tex">SE_2(3)</script> with left multiplication, i.e.</p><div><ul><li>the function <span class="MathJax_Preview"><img src="benchmark_inertial_navigation_eq17465938644384765962.png" alt="$\varphi(.,.)$"></span><script type="math/tex">\varphi(.,.)</script> is the <span class="MathJax_Preview"><img src="benchmark_inertial_navigation_eq02895149905820079520.png" alt="$SE_2(3)$"></span><script type="math/tex">SE_2(3)</script> exponnential, where the   state multiplies on the left the error <span class="MathJax_Preview"><img src="benchmark_inertial_navigation_eq07512430879093679749.png" alt="$\xi$"></span><script type="math/tex">\xi</script></li><li>the function <span class="MathJax_Preview"><img src="benchmark_inertial_navigation_eq03493348614921386861.png" alt="$\varphi^{-1}(.,.)$"></span><script type="math/tex">\varphi^{-1}(.,.)</script> is the <span class="MathJax_Preview"><img src="benchmark_inertial_navigation_eq02895149905820079520.png" alt="$SE_2(3)$"></span><script type="math/tex">SE_2(3)</script> logarithm</li></ul></div><p>3- The state is embedded in <span class="MathJax_Preview"><img src="benchmark_inertial_navigation_eq02895149905820079520.png" alt="$SE_2(3)$"></span><script type="math/tex">SE_2(3)</script> with right multiplication, i.e.</p><div><ul><li>the function <span class="MathJax_Preview"><img src="benchmark_inertial_navigation_eq17465938644384765962.png" alt="$\varphi(.,.)$"></span><script type="math/tex">\varphi(.,.)</script> is the <span class="MathJax_Preview"><img src="benchmark_inertial_navigation_eq02895149905820079520.png" alt="$SE_2(3)$"></span><script type="math/tex">SE_2(3)</script> exponnential, where state multiplies on the right the error <span class="MathJax_Preview"><img src="benchmark_inertial_navigation_eq07512430879093679749.png" alt="$\xi$"></span><script type="math/tex">\xi</script></li><li>the function <span class="MathJax_Preview"><img src="benchmark_inertial_navigation_eq03493348614921386861.png" alt="$\varphi^{-1}(.,.)$"></span><script type="math/tex">\varphi^{-1}(.,.)</script> is the <span class="MathJax_Preview"><img src="benchmark_inertial_navigation_eq02895149905820079520.png" alt="$SE_2(3)$"></span><script type="math/tex">SE_2(3)</script> logarithm</li><li>it corresponds to the Invariant Extended Kalman Filter (IEKF) recommanded in [1].</li></ul></div><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Initialization and Simulation Parameters</a></li><li><a href="#3">Filter Design</a></li><li><a href="#5">Monte-Carlo runs</a></li><li><a href="#6">Results</a></li><li><a href="#8">Conclusion</a></li></ul></div><h2 id="1">Initialization and Simulation Parameters</h2><p>Start by cleaning the workspace</p><pre class="codeinput">clear <span class="string">all</span>;
close <span class="string">all</span>;

<span class="comment">% Monte-Carlo runs</span>
N_mc = 1;

<span class="comment">% sequence time (s)</span>
T = 30;
<span class="comment">% IMU frequency (Hz)</span>
imu_freq = 100;
<span class="comment">% observation frequency (Hz)</span>
obs_freq = 1;
<span class="comment">% IMU standard-deviation noise (noise is isotropic)</span>
imu_noise_std = [0.01; <span class="comment">% gyro (rad/s), ~ 0.6 deg/s</span>
                0.01]; <span class="comment">% accelerometer (m/s^2)</span>
<span class="comment">% number of observed landmark</span>
N_ldk = 3;
<span class="comment">% observation noise standard deviation (m)</span>
obs_noise_std = 0.1;

<span class="comment">% total number of timestamps</span>
N = T*imu_freq;
<span class="comment">% time between succesive timestamps (s)</span>
dt = 1/imu_freq;
</pre><pre class="codeinput"><span class="comment">%The vehicle drives a 10-meter diameter circle</span>
<span class="comment">% in 30 seconds and observes three features  every second while receiving</span>
<span class="comment">% high-frequency inertial measurements (100 Hz).</span>
</pre><h2 id="3">Filter Design</h2><p>Additionnaly to the three UKFs, we compare them to an EKF and an IEKF. The EKF has the same uncertainty representation as the UKF with uncertainty representation 1), whereas the IEKF has the same uncertainty representation as the UKF with uncertainty representation 3). As we have five similar methods, the code is redundant.</p><pre class="codeinput"><span class="comment">% propagation noise matrix</span>
Q = blkdiag(imu_noise_std(1)^2*eye(3), imu_noise_std(2)^2*eye(3));
<span class="comment">% measurement noise matrix</span>
R = obs_noise_std.^2 * eye(3*N_ldk);
<span class="comment">% initial error matrix such that the state is not perfectly initialized</span>
init_rot_std = 15/sqrt(3)*pi/180;
init_p_std = 1/sqrt(3);
P0 = blkdiag(init_rot_std^2*eye(3), zeros(3, 3), init_p_std^2 * eye(3));

<span class="comment">% sigma point parameter</span>
ukf_alpha = [1e-3 1e-3 1e-3];

<span class="comment">% define the UKF functions</span>
ukf_f = @inertial_navigation_f;
ukf_h = @inertial_navigation_h;

ukf_phi = @inertial_navigation_phi;
ukf_left_phi = @inertial_navigation_left_phi;
ukf_right_phi = @inertial_navigation_right_phi;

ukf_phi_inv = @inertial_navigation_phi_inv;
ukf_left_phi_inv = @inertial_navigation_left_phi_inv;
ukf_right_phi_inv = @inertial_navigation_right_phi_inv;

ukf_weights = ukf_set_weight(length(P0), length(Q), ukf_alpha);
ukf_cholQ = chol(Q);
</pre><p>We set error variables before launching Monte-Carlo simulations</p><pre class="codeinput">ukf_left_err = zeros(2, N_mc);
ukf_right_err = zeros(2, N_mc);
ukf_err = zeros(2, N_mc);
iekf_err = zeros(2, N_mc);
ekf_err = zeros(2, N_mc);
</pre><h2 id="5">Monte-Carlo runs</h2><p>Run the Monte-Carlo loop and be patient</p><pre class="codeinput"><span class="keyword">for</span> n_mc = 1:N_mc
    disp(<span class="string">"Monte-Carlo iteration(s): "</span> + num2str(n_mc) + <span class="string">"/"</span> + num2str(N_mc));
   <span class="comment">% simulate true trajectory and noised input</span>
    [true_state, omega] = inertial_navigation_simu_f(T, imu_freq, <span class="keyword">...</span>
        imu_noise_std);
    <span class="comment">% simulate amers measurements</span>
    [y, one_hot_y] = inertial_navigation_simu_h(true_state, T, imu_freq, <span class="keyword">...</span>
        obs_freq, obs_noise_std);

    <span class="comment">% initialize filter with innacurate state</span>
    ukf_state = true_state(1);
    <span class="comment">% we sample an initial error from the true distribution. This</span>
    <span class="comment">% is the correct manner to compare the filters but requires more</span>
    <span class="comment">% Monte-Carlo samples than a static values</span>
    init_rot_err = so3_exp(init_rot_std*ones(3, 1));
    init_p_err = init_p_std*ones(3, 1);
    ukf_state.Rot = init_rot_err * ukf_state.Rot;
    ukf_state.p = ukf_state.p + init_p_err;

    ukf_left_state = ukf_state(1);
    ukf_right_state = ukf_state(1);
    ekf_state = ukf_state(1);
    iekf_state = ukf_state(1);

    ukf_P = P0;
    ukf_left_P = P0;
    ukf_right_P = P0;
    ekf_P = P0;
    iekf_P = P0;

    <span class="comment">% IEKF and right UKF covariance need to be turned [1]</span>
    J = eye(9);
    J(7:9,1:3) = so3_wedge(iekf_state.p);
    ukf_right_P = J*ukf_right_P*J';
    iekf_P = J*iekf_P*J';

    <span class="comment">% variables for recording estimates of the Monte-Carlo run</span>
    ukf_states = ukf_state;
    ukf_left_states = ukf_left_state;
    ukf_right_states = ukf_right_state;
    iekf_states = iekf_state;
    ekf_states = ekf_state;

    ukf_Ps = zeros(N, 9, 9);
    ukf_left_Ps = zeros(N, 9, 9);
    ukf_right_Ps = zeros(N, 9, 9);
    ekf_Ps = zeros(N, 9, 9);
    iekf_Ps = zeros(N, 9, 9);

    ukf_Ps(1, :, :) = ukf_P;
    ukf_left_Ps(1, :, :) = ukf_left_P;
    ukf_right_Ps(1, :, :) = ukf_right_P;
    ekf_Ps(1, :, :) = ekf_P;
    iekf_Ps(1, :, :) = iekf_P;

    <span class="comment">% measurement iteration number</span>
    k = 2;

    <span class="comment">% filtering loop</span>
    <span class="keyword">for</span> n = 2:N
        <span class="comment">% propagation</span>
        [ukf_state, ukf_P] = ukf_propagation(ukf_state, ukf_P, omega(n-1), <span class="keyword">...</span>
            ukf_f, dt, ukf_phi, ukf_phi_inv, ukf_cholQ, ukf_weights);
        [ukf_left_state, ukf_left_P] = ukf_propagation(ukf_left_state, <span class="keyword">...</span>
            ukf_left_P, omega(n-1), ukf_f, dt, ukf_left_phi, <span class="keyword">...</span>
            ukf_left_phi_inv, ukf_cholQ, ukf_weights);
        [ukf_right_state, ukf_right_P] = ukf_propagation(<span class="keyword">...</span>
            ukf_right_state, ukf_right_P, omega(n-1), <span class="keyword">...</span>
            ukf_f, dt, ukf_right_phi, ukf_right_phi_inv, ukf_cholQ, <span class="keyword">...</span>
            ukf_weights);
        [ekf_state, ekf_P] = inertial_navigation_ekf_propagation(ekf_state, <span class="keyword">...</span>
            ekf_P, omega(n-1), dt, Q);
        [iekf_state, iekf_P] = inertial_navigation_iekf_propagation(<span class="keyword">...</span>
            iekf_state, iekf_P, omega(n-1), dt, Q);

        <span class="comment">% update only if a measurement is received</span>
        <span class="keyword">if</span> one_hot_y(n) == 1
           [ukf_state, ukf_P] = ukf_update(ukf_state, ukf_P, <span class="keyword">...</span>
               y(:, k), ukf_h, ukf_phi, R, ukf_weights);
           [ukf_left_state, ukf_left_P] = ukf_update(ukf_left_state, <span class="keyword">...</span>
               ukf_left_P, y(:, k), ukf_h, ukf_left_phi, R, ukf_weights);
           [ukf_right_state, ukf_right_P] = ukf_update(ukf_right_state, <span class="keyword">...</span>
               ukf_right_P, y(:, k), ukf_h, ukf_right_phi, <span class="keyword">...</span>
               R, ukf_weights);
           [ekf_state, ekf_P] = inertial_navigation_ekf_update(ekf_state, <span class="keyword">...</span>
               ekf_P, y(:, k), R);
           [iekf_state, iekf_P] = inertial_navigation_iekf_update(iekf_state, <span class="keyword">...</span>
               iekf_P, y(:, k), R);
            k = k + 1;
        <span class="keyword">end</span>
        <span class="comment">% save estimates</span>
        ukf_states(n) = ukf_state;
        ukf_left_states(n) = ukf_left_state;
        ukf_right_states(n) = ukf_right_state;
        ekf_states(n) = ekf_state;
        iekf_states(n) = iekf_state;

        ukf_Ps(n, :, :) = ukf_P;
        ukf_left_Ps(n, :, :) = ukf_left_P;
        ukf_right_Ps(n, :, :) = ukf_right_P;
        ekf_Ps(n, :, :) = ekf_P;
        iekf_Ps(n, :, :) = iekf_P;

    <span class="keyword">end</span>
    <span class="comment">% record errors</span>
    ukf_left_err(:, n_mc) = inertial_navigation_error(true_state, ukf_left_states);
    ukf_right_err(:, n_mc) = inertial_navigation_error(true_state, ukf_right_states);
    ukf_err(:, n_mc) = inertial_navigation_error(true_state, ukf_states);
    iekf_err(:, n_mc) = inertial_navigation_error(true_state, iekf_states);
    ekf_err(:, n_mc) = inertial_navigation_error(true_state, ekf_states);
<span class="keyword">end</span>
</pre><pre class="codeoutput">Monte-Carlo iteration(s): 1/1
</pre><h2 id="6">Results</h2><p>Simulations are ended, we can know compare the algorithms. Let us visualize the results for the last run. As simulations have random process, they just give us an indication but not a proof of filter performances.</p><p>More interesting is to compute results averaged over all the Monte-Carlo. Let us compute the Root Mean Squared Error (RMSE)for each method both for the orientation and the position.</p><pre class="codeinput">benchmark_inertial_navigation_helper;
</pre><pre class="codeoutput"> 
Root Mean Square Error w.r.t. orientation (deg)
    -standard UKF: 2.83
    -left UKF    : 2.79
    -right UKF   : 2.79
    -EKF         : 4.20
    -IEKF        : 3.46
 
Root Mean Square Error w.r.t. position (m)
    -standard UKF: 0.21
    -left UKF    : 0.20
    -right UKF   : 0.20
    -EKF         : 0.47
    -IEKF        : 0.25
</pre><img vspace="5" hspace="5" src="benchmark_inertial_navigation_01.png" alt=""> <img vspace="5" hspace="5" src="benchmark_inertial_navigation_02.png" alt=""> <p>For the considered Monte-Carlo, we first obserce that EKF is not working very well. Then, it happends that the UKFs are better than IEKF once filters have converged, whereas IEKF, left UKF and right UKF are better in the first instants of the trajectory.</p><h2 id="8">Conclusion</h2><p>This script compares different algorithm on the navigation on flat Earth example. The left UKF and right UKF seems sligthly better.</p><p>You can now confirm (or infirm) the obtained results on massive Monte-Carlo simulation. Another relavant comparaison consists in testing the filters when propagation noise is very low (standard deviation of <span class="MathJax_Preview"><img src="benchmark_inertial_navigation_eq06294580275139675239.png" alt="$10^{-4}$"></span><script type="math/tex">10^{-4}</script>), as suggested in [1].</p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Benchmark of Navigation on Flat Earth Example
% Goals of this script
% 
% * implement different UKFs on the navigation on flat Earth example
% * design the Extended Kalman Filter (EKF) and the Invariant Extended 
%   Kalman Filter (IEKF) [1] for the given problem
% * compare the different algorithms with Monte-Carlo simulations
% 
% _We assume the reader is already familiar with the considered 
% problem described in the example folder._
%
% For the given, three different UKFs emerge, defined respectively as:
% 
% 1- The state is embedded in $SO(3) \times R^6$, i.e.
% 
% * the function $\varphi(.,.)$ is the $SO(3)$ error for orientation, and
%  the standard vector addition for robot position
% * the function $\varphi^{-1}$ is the $SO(3)$ logarithm for orientation
%  and the standard vector substraction for position
% * it is the standard UKF
% 
% 2- The state is embedded in $SE_2(3)$ with left multiplication, i.e.
%
% * the function $\varphi(.,.)$ is the $SE_2(3)$ exponnential, where the
%   state multiplies on the left the error $\xi$
% * the function $\varphi^{-1}(.,.)$ is the $SE_2(3)$ logarithm
%
% 3- The state is embedded in $SE_2(3)$ with right multiplication, i.e.
%     
% * the function $\varphi(.,.)$ is the $SE_2(3)$ exponnential, where state
% multiplies on the right the error $\xi$
% * the function $\varphi^{-1}(.,.)$ is the $SE_2(3)$ logarithm
% * it corresponds to the Invariant Extended Kalman Filter (IEKF)
% recommanded in [1]. 

%% Initialization and Simulation Parameters
% Start by cleaning the workspace.
clear all;
close all;

% Monte-Carlo runs
N_mc = 1;

% sequence time (s)
T = 30;
% IMU frequency (Hz)
imu_freq = 100;
% observation frequency (Hz)
obs_freq = 1;
% IMU standard-deviation noise (noise is isotropic)
imu_noise_std = [0.01; % gyro (rad/s), ~ 0.6 deg/s
                0.01]; % accelerometer (m/s^2)
% number of observed landmark
N_ldk = 3;
% observation noise standard deviation (m)
obs_noise_std = 0.1;

% total number of timestamps
N = T*imu_freq;
% time between succesive timestamps (s)
dt = 1/imu_freq;

%%
%The vehicle drives a 10-meter diameter circle
% in 30 seconds and observes three features  every second while receiving
% high-frequency inertial measurements (100 Hz).

%% Filter Design
% Additionnaly to the three UKFs, we compare them to an EKF and an IEKF.
% The EKF has the same uncertainty representation as the UKF with uncertainty representation 1),
% whereas the IEKF has the same uncertainty representation as the UKF with error
% 3). As we have five similar methods, the code is redundant.

% propagation noise matrix
Q = blkdiag(imu_noise_std(1)^2*eye(3), imu_noise_std(2)^2*eye(3));
% measurement noise matrix
R = obs_noise_std.^2 * eye(3*N_ldk);
% initial error matrix such that the state is not perfectly initialized
init_rot_std = 15/sqrt(3)*pi/180;
init_p_std = 1/sqrt(3);
P0 = blkdiag(init_rot_std^2*eye(3), zeros(3, 3), init_p_std^2 * eye(3));

% sigma point parameter
ukf_alpha = [1e-3 1e-3 1e-3];

% define the UKF functions
ukf_f = @inertial_navigation_f;
ukf_h = @inertial_navigation_h;

ukf_phi = @inertial_navigation_phi;
ukf_left_phi = @inertial_navigation_left_phi;
ukf_right_phi = @inertial_navigation_right_phi;

ukf_phi_inv = @inertial_navigation_phi_inv;
ukf_left_phi_inv = @inertial_navigation_left_phi_inv;
ukf_right_phi_inv = @inertial_navigation_right_phi_inv;

ukf_weights = ukf_set_weight(length(P0), length(Q), ukf_alpha);
ukf_cholQ = chol(Q);

%%
% We set error variables before launching Monte-Carlo simulations
ukf_left_err = zeros(2, N_mc);
ukf_right_err = zeros(2, N_mc);
ukf_err = zeros(2, N_mc);
iekf_err = zeros(2, N_mc);
ekf_err = zeros(2, N_mc);

%% Monte-Carlo runs
% Run the Monte-Carlo loop and be patient

for n_mc = 1:N_mc
    disp("Monte-Carlo iteration(s): " + num2str(n_mc) + "/" + num2str(N_mc));
   % simulate true trajectory and noised input
    [true_state, omega] = inertial_navigation_simu_f(T, imu_freq, ...
        imu_noise_std);
    % simulate amers measurements
    [y, one_hot_y] = inertial_navigation_simu_h(true_state, T, imu_freq, ...
        obs_freq, obs_noise_std);

    % initialize filter with innacurate state
    ukf_state = true_state(1);
    % we sample an initial error from the true distribution. This
    % is the correct manner to compare the filters but requires more
    % Monte-Carlo samples than a static values
    init_rot_err = so3_exp(init_rot_std*ones(3, 1));
    init_p_err = init_p_std*ones(3, 1);
    ukf_state.Rot = init_rot_err * ukf_state.Rot;
    ukf_state.p = ukf_state.p + init_p_err;
    
    ukf_left_state = ukf_state(1);
    ukf_right_state = ukf_state(1);
    ekf_state = ukf_state(1);
    iekf_state = ukf_state(1);
    
    ukf_P = P0;
    ukf_left_P = P0;
    ukf_right_P = P0;
    ekf_P = P0;
    iekf_P = P0;
    
    % IEKF and right UKF covariance need to be turned [1]
    J = eye(9);
    J(7:9,1:3) = so3_wedge(iekf_state.p);
    ukf_right_P = J*ukf_right_P*J';
    iekf_P = J*iekf_P*J';
    
    % variables for recording estimates of the Monte-Carlo run
    ukf_states = ukf_state;
    ukf_left_states = ukf_left_state;
    ukf_right_states = ukf_right_state;
    iekf_states = iekf_state;
    ekf_states = ekf_state;
    
    ukf_Ps = zeros(N, 9, 9);
    ukf_left_Ps = zeros(N, 9, 9);
    ukf_right_Ps = zeros(N, 9, 9);
    ekf_Ps = zeros(N, 9, 9);
    iekf_Ps = zeros(N, 9, 9);
    
    ukf_Ps(1, :, :) = ukf_P;
    ukf_left_Ps(1, :, :) = ukf_left_P;
    ukf_right_Ps(1, :, :) = ukf_right_P;
    ekf_Ps(1, :, :) = ekf_P;
    iekf_Ps(1, :, :) = iekf_P;
    
    % measurement iteration number
    k = 2;

    % filtering loop
    for n = 2:N
        % propagation
        [ukf_state, ukf_P] = ukf_propagation(ukf_state, ukf_P, omega(n-1), ...
            ukf_f, dt, ukf_phi, ukf_phi_inv, ukf_cholQ, ukf_weights);
        [ukf_left_state, ukf_left_P] = ukf_propagation(ukf_left_state, ...
            ukf_left_P, omega(n-1), ukf_f, dt, ukf_left_phi, ...
            ukf_left_phi_inv, ukf_cholQ, ukf_weights);
        [ukf_right_state, ukf_right_P] = ukf_propagation(...
            ukf_right_state, ukf_right_P, omega(n-1), ...
            ukf_f, dt, ukf_right_phi, ukf_right_phi_inv, ukf_cholQ, ...
            ukf_weights);
        [ekf_state, ekf_P] = inertial_navigation_ekf_propagation(ekf_state, ...
            ekf_P, omega(n-1), dt, Q);
        [iekf_state, iekf_P] = inertial_navigation_iekf_propagation(...
            iekf_state, iekf_P, omega(n-1), dt, Q);
   
        % update only if a measurement is received
        if one_hot_y(n) == 1
           [ukf_state, ukf_P] = ukf_update(ukf_state, ukf_P, ...
               y(:, k), ukf_h, ukf_phi, R, ukf_weights);
           [ukf_left_state, ukf_left_P] = ukf_update(ukf_left_state, ...
               ukf_left_P, y(:, k), ukf_h, ukf_left_phi, R, ukf_weights);           
           [ukf_right_state, ukf_right_P] = ukf_update(ukf_right_state, ...
               ukf_right_P, y(:, k), ukf_h, ukf_right_phi, ...
               R, ukf_weights);
           [ekf_state, ekf_P] = inertial_navigation_ekf_update(ekf_state, ...
               ekf_P, y(:, k), R);
           [iekf_state, iekf_P] = inertial_navigation_iekf_update(iekf_state, ...
               iekf_P, y(:, k), R);
            k = k + 1;
        end
        % save estimates
        ukf_states(n) = ukf_state;
        ukf_left_states(n) = ukf_left_state;
        ukf_right_states(n) = ukf_right_state;
        ekf_states(n) = ekf_state;
        iekf_states(n) = iekf_state;
        
        ukf_Ps(n, :, :) = ukf_P;
        ukf_left_Ps(n, :, :) = ukf_left_P;
        ukf_right_Ps(n, :, :) = ukf_right_P;
        ekf_Ps(n, :, :) = ekf_P;
        iekf_Ps(n, :, :) = iekf_P;
        
    end
    % record errors
    ukf_left_err(:, n_mc) = inertial_navigation_error(true_state, ukf_left_states);
    ukf_right_err(:, n_mc) = inertial_navigation_error(true_state, ukf_right_states);
    ukf_err(:, n_mc) = inertial_navigation_error(true_state, ukf_states);
    iekf_err(:, n_mc) = inertial_navigation_error(true_state, iekf_states);
    ekf_err(:, n_mc) = inertial_navigation_error(true_state, ekf_states);
end

%% Results
% Simulations are ended, we can know compare the algorithms. Let us
% visualize the results for the last run. As simulations have random
% process, they just give us an indication but not a proof of filter
% performances.
%
% More interesting is to compute results averaged over all the Monte-Carlo.
% Let us compute the Root Mean Squared Error (RMSE)for each method both for
% the orientation and the position.

benchmark_inertial_navigation_helper;


%%
% For the considered Monte-Carlo, we first obserce that EKF is not working
% very well. Then, it happends that the UKFs are better than IEKF once
% filters have converged, whereas IEKF, left UKF and right UKF are better
% in the first instants of the trajectory.

%% Conclusion
% This script compares different algorithm on the navigation on flat Earth
% example. The left UKF and right UKF seems sligthly better.
%
% You can now confirm (or infirm) the obtained results on massive
% Monte-Carlo simulation. Another relavant comparaison consists in testing
% the filters when propagation noise is very low (standard deviation of
% $10^{-4}$), as suggested in [1].

##### SOURCE END #####
--></body></html>