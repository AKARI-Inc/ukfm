
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Benchmark of the 2D Robot Localization Example</title><meta name="generator" content="MATLAB 9.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-08-29"><meta name="DC.source" content="benchmark_localization.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Benchmark of the 2D Robot Localization Example</h1><!--introduction--><p>Goals of this script</p><div><ul><li>implement different UKFs on the 2D robot localization example</li><li>design the Extended Kalman Filter (EKF) and the Invariant Extended   Kalman Filter (IEKF) [1] for the given problem</li><li>compare the different algorithms with Monte-Carlo simulations</li></ul></div><p><i>We assume the reader is already familiar with the considered problem described in the example folder.</i></p><p>We previously designed an UKF with a standard uncertainty representation. An advantage of the versatility of the UKF is to fastly implement, test, and compare UKF with different uncertainty representation. Indeed, for the given, three different UKFs emerge, defined respectively as:</p><p>1- The state is embedded in <span class="MathJax_Preview"><img src="benchmark_localization_eq11736377486177990312.png" alt="$SO(2) \times R^2$"></span><script type="math/tex">SO(2) \times R^2</script>, as in the exemple, where</p><div><ul><li>the function <span class="MathJax_Preview"><img src="benchmark_localization_eq17465938644384765962.png" alt="$\varphi(.,.)$"></span><script type="math/tex">\varphi(.,.)</script> is the <span class="MathJax_Preview"><img src="benchmark_localization_eq03814562234001690102.png" alt="$SO(2)$"></span><script type="math/tex">SO(2)</script> exponential map for  orientation and the standard vector addition for robot position</li><li>the function <span class="MathJax_Preview"><img src="benchmark_localization_eq03493348614921386861.png" alt="$\varphi^{-1}(.,.)$"></span><script type="math/tex">\varphi^{-1}(.,.)</script> is the <span class="MathJax_Preview"><img src="benchmark_localization_eq03814562234001690102.png" alt="$SO(2)$"></span><script type="math/tex">SO(2)</script> logarithm for orientation and the standard vector substraction for position</li></ul></div><p>2- The state is embedded in <span class="MathJax_Preview"><img src="benchmark_localization_eq03280883000971701062.png" alt="$SE(2)$"></span><script type="math/tex">SE(2)</script> with left multiplication, i.e.</p><div><ul><li>the function <span class="MathJax_Preview"><img src="benchmark_localization_eq17465938644384765962.png" alt="$\varphi(.,.)$"></span><script type="math/tex">\varphi(.,.)</script> is the <span class="MathJax_Preview"><img src="benchmark_localization_eq03280883000971701062.png" alt="$SE(2)$"></span><script type="math/tex">SE(2)</script> exponnential, where the   state multiplies on the left the error <span class="MathJax_Preview"><img src="benchmark_localization_eq07512430879093679749.png" alt="$\xi$"></span><script type="math/tex">\xi</script></li><li>the function <span class="MathJax_Preview"><img src="benchmark_localization_eq03493348614921386861.png" alt="$\varphi^{-1}(.,.)$"></span><script type="math/tex">\varphi^{-1}(.,.)</script> is the <span class="MathJax_Preview"><img src="benchmark_localization_eq03280883000971701062.png" alt="$SE(2)$"></span><script type="math/tex">SE(2)</script> logarithm</li><li>it corresponds to the Invariant Extended Kalman Filter (IEKF) recommanded in [1]. We have theoritical reason to choose this error.</li></ul></div><p>3- The state is embedded in <span class="MathJax_Preview"><img src="benchmark_localization_eq03280883000971701062.png" alt="$SE(2)$"></span><script type="math/tex">SE(2)</script> with right multiplication, i.e.</p><div><ul><li>the function <span class="MathJax_Preview"><img src="benchmark_localization_eq17465938644384765962.png" alt="$\varphi(.,.)$"></span><script type="math/tex">\varphi(.,.)</script> is the <span class="MathJax_Preview"><img src="benchmark_localization_eq03280883000971701062.png" alt="$SE(2)$"></span><script type="math/tex">SE(2)</script> exponnential, where state multiplies on the right the error <span class="MathJax_Preview"><img src="benchmark_localization_eq07512430879093679749.png" alt="$\xi$"></span><script type="math/tex">\xi</script></li><li>the function <span class="MathJax_Preview"><img src="benchmark_localization_eq03493348614921386861.png" alt="$\varphi^{-1}(.,.)$"></span><script type="math/tex">\varphi^{-1}(.,.)</script> is the <span class="MathJax_Preview"><img src="benchmark_localization_eq03280883000971701062.png" alt="$SE(2)$"></span><script type="math/tex">SE(2)</script> logarithm</li><li>we do not dispose of reason to choose this error but test it as it is so simple</li></ul></div><p>We will see how the results confirm the theory or not.</p><p>[1] Barrau, A., &amp; Bonnabel, S. (2016). The invariant extended Kalman filter as a stable observer. IEEE Transactions on Automatic Control, 62(4), 1797-1812.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Initialization and Simulation Parameters</a></li><li><a href="#3">Filter Design</a></li><li><a href="#5">Monte-Carlo runs</a></li><li><a href="#6">Results</a></li><li><a href="#9">Conclusion</a></li></ul></div><h2 id="1">Initialization and Simulation Parameters</h2><p>Start by cleaning the workspace</p><pre class="codeinput">clear <span class="string">all</span>;
close <span class="string">all</span>;
</pre><p>We set the simulation as in [1], section IV. The robot drives along a 10 m diameter circle for 40 seconds with high rate odometer measurements (100 Hz) and low rate GPS measurements (1 Hz). The vehicle gets moderate angular velocity uncertainty and highly precise linear velocity. The initial values of the heading error is 45&deg; while the initial position is known.</p><pre class="codeinput"><span class="comment">% Monte-Carlo runs</span>
N_mc = 5;
<span class="comment">% sequence time (s)</span>
T = 40;
<span class="comment">% odometry frequency (Hz)</span>
odo_freq = 100;
<span class="comment">% odometry noise standard deviation</span>
odo_noise_std = [0.01; <span class="comment">% speed (v/m)</span>
                 0.01; <span class="comment">% speed (v/m)</span>
                 1/180*pi]; <span class="comment">% angular speed (rad/s)</span>
<span class="comment">% GPS frequency (Hz)</span>
gps_freq = 1;
<span class="comment">% GPS noise standard deviation (m)</span>
gps_noise_std = 1;

<span class="comment">% total number of timestamps</span>
N = T*odo_freq;
<span class="comment">% time between succesive timestamps (s)</span>
dt = 1/odo_freq;
<span class="comment">% radius of the circle trajectory (m)</span>
radius = 5;
</pre><h2 id="3">Filter Design</h2><p>Additionnaly to the three UKFs, we compare them to an EKF and an IEKF. The EKF has the same uncertainty representation as the UKF with uncertainty representation 1), whereas the IEKF has the same uncertainty representation as the UKF with uncertainty representation 2). As we have five similar methods, the code is redundant.</p><pre class="codeinput"><span class="comment">% propagation noise matrix</span>
Q = diag(odo_noise_std.^2);

<span class="comment">% measurement noise matrix</span>
R = gps_noise_std^2 * eye(2);

<span class="comment">% initial error matrix</span>
P0 = zeros(3, 3);
init_heading_error_std = 45/180*pi;
<span class="comment">% we take into account initial heading error</span>
P0(1, 1) = (init_heading_error_std)^2;
ukf_right_P0 = P0; <span class="comment">% this is correct for your situation, see [1]</span>
ukf_left_P0 = P0;
iekf_left_P0 = P0;

<span class="comment">% sigma point parameter</span>
ukf_alpha = [1e-3 1e-3 1e-3];

<span class="comment">% define the UKF functions</span>
ukf_f = @localization_f;
ukf_h = @localization_h;

ukf_phi = @localization_phi;
ukf_left_phi = @localization_left_phi;
ukf_right_phi = @localization_right_phi;

ukf_phi_inv = @localization_phi_inv;
ukf_left_phi_inv = @localization_left_phi_inv;
ukf_right_phi_inv = @localization_right_phi_inv;

ukf_weights = ukf_set_weight(length(P0), length(Q), ukf_alpha);
ukf_cholQ = chol(Q);
</pre><p>We set error variables before launching Monte-Carlo simulations</p><pre class="codeinput">ukf_left_err = zeros(2, N_mc);
ukf_right_err = zeros(2, N_mc);
ukf_err = zeros(2, N_mc);
iekf_err = zeros(2, N_mc);
ekf_err = zeros(2, N_mc);
</pre><h2 id="5">Monte-Carlo runs</h2><p>Run the Monte-Carlo loop and be patient</p><pre class="codeinput"><span class="keyword">for</span> n_mc = 1:N_mc
    disp(<span class="string">"Monte-Carlo iteration(s): "</span> + num2str(n_mc) + <span class="string">"/"</span> + num2str(N_mc));
    <span class="comment">% simulation true trajectory</span>
    [true_state, omega] = localization_simu_f(T, odo_freq, <span class="keyword">...</span>
        odo_noise_std, radius);
    <span class="comment">% simulate measurement</span>
    [y, one_hot_y] = localization_simu_h(true_state, T, odo_freq, <span class="keyword">...</span>
    gps_freq, gps_noise_std);

    <span class="comment">% initialize filter with innacurate state</span>
    ukf_state = true_state(1);
    <span class="comment">% we sample an initial heading error from the true distribution. This</span>
    <span class="comment">% is the correct manner to compare the filters but requires more</span>
    <span class="comment">% Monte-Carlo samples than a static values</span>
    init_heading_error = init_heading_error_std*randn(1);
    ukf_state.Rot = true_state(1).Rot * so2_exp(init_heading_error);
    ukf_left_state = ukf_state(1);
    ukf_right_state = ukf_state(1);
    ekf_state = ukf_state(1);
    iekf_state = ukf_state(1);

    ukf_P = P0;
    ukf_left_P = ukf_left_P0;
    ukf_right_P = ukf_right_P0;
    ekf_P = P0;
    iekf_P = ukf_left_P0;

    <span class="comment">% variables for recording estimates of the Monte-Carlo run</span>
    ukf_states = ukf_state;
    ukf_left_states = ukf_left_state;
    ukf_right_states = ukf_right_state;
    iekf_states = iekf_state;
    ekf_states = ekf_state;

    ukf_Ps = zeros(N, 3, 3);
    ukf_left_Ps = zeros(N, 3, 3);
    ukf_right_Ps = zeros(N, 3, 3);
    ekf_Ps = zeros(N, 3, 3);
    iekf_Ps = zeros(N, 3, 3);

    ukf_Ps(1, :, :) = ukf_P;
    ukf_left_Ps(1, :, :) = ukf_left_P;
    ukf_right_Ps(1, :, :) = ukf_right_P;
    ekf_Ps(1, :, :) = ekf_P;
    iekf_Ps(1, :, :) = iekf_P;

    <span class="comment">% measurement iteration number</span>
    k = 2;

    <span class="comment">% filtering loop</span>
    <span class="keyword">for</span> n = 2:N
        <span class="comment">% propagation</span>
        [ukf_state, ukf_P] = ukf_propagation(ukf_state, ukf_P, omega(n-1), <span class="keyword">...</span>
            ukf_f, dt, ukf_phi, ukf_phi_inv, ukf_cholQ, ukf_weights);
        [ukf_left_state, ukf_left_P] = ukf_propagation(ukf_left_state, <span class="keyword">...</span>
            ukf_left_P, omega(n-1), ukf_f, dt, ukf_left_phi, <span class="keyword">...</span>
            ukf_left_phi_inv, ukf_cholQ, ukf_weights);
        [ukf_right_state, ukf_right_P] = ukf_propagation(<span class="keyword">...</span>
            ukf_right_state, ukf_right_P, omega(n-1), <span class="keyword">...</span>
            ukf_f, dt, ukf_right_phi, ukf_right_phi_inv, ukf_cholQ, <span class="keyword">...</span>
            ukf_weights);
        [ekf_state, ekf_P] = localization_ekf_propagation(ekf_state, <span class="keyword">...</span>
            ekf_P, omega(n-1), dt, Q);
        [iekf_state, iekf_P] = localization_iekf_propagation(<span class="keyword">...</span>
            iekf_state, iekf_P, omega(n-1), dt, Q);

        <span class="comment">% update only if a measurement is received</span>
        <span class="keyword">if</span> one_hot_y(n) == 1
           [ukf_state, ukf_P] = ukf_update(ukf_state, ukf_P, <span class="keyword">...</span>
               y(:, k), ukf_h, ukf_phi, R, ukf_weights);
           [ukf_left_state, ukf_left_P] = ukf_update(ukf_left_state, <span class="keyword">...</span>
               ukf_left_P, y(:, k), ukf_h, ukf_left_phi, R, ukf_weights);
           [ukf_right_state, ukf_right_P] = ukf_update(ukf_right_state, <span class="keyword">...</span>
               ukf_right_P, y(:, k), ukf_h, ukf_right_phi, <span class="keyword">...</span>
               R, ukf_weights);
           [ekf_state, ekf_P] = localization_ekf_update(ekf_state, <span class="keyword">...</span>
               ekf_P, y(:, k), R);
           [iekf_state, iekf_P] = localization_iekf_update(iekf_state, <span class="keyword">...</span>
               iekf_P, y(:, k), R);
            k = k + 1;
        <span class="keyword">end</span>
        <span class="comment">% save estimates</span>
        ukf_states(n) = ukf_state;
        ukf_left_states(n) = ukf_left_state;
        ukf_right_states(n) = ukf_right_state;
        ekf_states(n) = ekf_state;
        iekf_states(n) = iekf_state;

        ukf_Ps(n, :, :) = ukf_P;
        ukf_left_Ps(n, :, :) = ukf_left_P;
        ukf_right_Ps(n, :, :) = ukf_right_P;
        ekf_Ps(n, :, :) = ekf_P;
        iekf_Ps(n, :, :) = iekf_P;

    <span class="keyword">end</span>
    <span class="comment">% record errors</span>
    ukf_left_err(:, n_mc) = localization_error(true_state, ukf_left_states);
    ukf_right_err(:, n_mc) = localization_error(true_state, ukf_right_states);
    ukf_err(:, n_mc) = localization_error(true_state, ukf_states);
    iekf_err(:, n_mc) = localization_error(true_state, iekf_states);
    ekf_err(:, n_mc) = localization_error(true_state, ekf_states);
<span class="keyword">end</span>
</pre><pre class="codeoutput">Monte-Carlo iteration(s): 1/5
Monte-Carlo iteration(s): 2/5
Monte-Carlo iteration(s): 3/5
Monte-Carlo iteration(s): 4/5
Monte-Carlo iteration(s): 5/5
</pre><h2 id="6">Results</h2><p>Simulations are ended, we can know compare the algorithms. Let us visualize the results for the last run. As simulations have random process, they just give us an indication but not a proof of filter performances.</p><pre class="codeinput">benchmark_localization_helper;
</pre><img vspace="5" hspace="5" src="benchmark_localization_01.png" alt=""> <p>More interesting is to compute results averaged over all the Monte-Carlo. Let us compute the Root Mean Squared Error (RMSE)for each method both for the orientation and the position.</p><pre class="codeinput">disp(<span class="string">' '</span>)
disp(<span class="string">'Root Mean Square Error w.r.t. orientation (deg)'</span>);
disp(<span class="string">"    -standard UKF: "</span> + ukf_err_rot);
disp(<span class="string">"    -left UKF    : "</span> + ukf_left_err_rot);
disp(<span class="string">"    -right UKF   : "</span> + ukf_right_err_rot);
disp(<span class="string">"    -EKF         : "</span> + ekf_err_rot);
disp(<span class="string">"    -IEKF        : "</span> + iekf_err_rot);

disp(<span class="string">' '</span>)
disp(<span class="string">'Root Mean Square Error w.r.t. position (m)'</span>);
disp(<span class="string">"    -standard UKF: "</span> + ukf_err_p);
disp(<span class="string">"    -left UKF    : "</span> + ukf_left_err_p);
disp(<span class="string">"    -right UKF   : "</span> + ukf_right_err_p);
disp(<span class="string">"    -EKF         : "</span> + ekf_err_p);
disp(<span class="string">"    -IEKF        : "</span> + iekf_err_p);
</pre><pre class="codeoutput"> 
Root Mean Square Error w.r.t. orientation (deg)
    -standard UKF: 0.32
    -left UKF    : 0.29
    -right UKF   : 0.29
    -EKF         : 0.32
    -IEKF        : 0.29
 
Root Mean Square Error w.r.t. position (m)
    -standard UKF: 1.18
    -left UKF    : 0.55
    -right UKF   : 0.55
    -EKF         : 1.20
    -IEKF        : 0.55
</pre><p>Which filter is the best ? We expect it is the left UKF as it takes advantage of both theory of IEKF uncertainty representation and better noise incorporation of UKF compared to EKF. Depending on which source of error (sensor noise, initial condition) is the most important, it can lead to different results. We also note that we have set all the filters with the same "true" noise covariance parameters. Hovewer, both EKF and UKF based algorihms may better deal with non-linearity by e.g. inflated propagation noise covariance.</p><h2 id="9">Conclusion</h2><p>best of iekf and UKF importance of noise and theory. Surprisingly UKF. Try other simulation parameters. Results can change. display error, other metrics</p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Benchmark of the 2D Robot Localization Example
% Goals of this script
% 
% * implement different UKFs on the 2D robot localization example
% * design the Extended Kalman Filter (EKF) and the Invariant Extended 
%   Kalman Filter (IEKF) [1] for the given problem
% * compare the different algorithms with Monte-Carlo simulations
% 
% _We assume the reader is already familiar with the considered 
% problem described in the example folder._
%
% We previously designed an UKF with a standard uncertainty representation. An
% advantage of the versatility of the UKF is to fastly implement, test, and
% compare UKF with different uncertainty representation. Indeed, for the given,
% three different UKFs emerge, defined respectively as:
% 
% 1- The state is embedded in $SO(2) \times R^2$, as in the exemple, where
% 
% * the function $\varphi(.,.)$ is the $SO(2)$ exponential map for 
%  orientation and the standard vector addition for robot position
% * the function $\varphi^{-1}(.,.)$ is the $SO(2)$ logarithm for
% orientation and the standard vector substraction for position
%     
% 2- The state is embedded in $SE(2)$ with left multiplication, i.e.
%
% * the function $\varphi(.,.)$ is the $SE(2)$ exponnential, where the
%   state multiplies on the left the error $\xi$
% * the function $\varphi^{-1}(.,.)$ is the $SE(2)$ logarithm
% * it corresponds to the Invariant Extended Kalman Filter (IEKF)
% recommanded in [1]. We have theoritical reason to choose this error.
%
% 3- The state is embedded in $SE(2)$ with right multiplication, i.e.
%     
% * the function $\varphi(.,.)$ is the $SE(2)$ exponnential, where state is 
% multiplies on the right the error $\xi$
% * the function $\varphi^{-1}(.,.)$ is the $SE(2)$ logarithm
% * we do not dispose of reason to choose this error but test it as it is 
% so simple
%
% We will see how the results confirm the theory or not.
%
% [1] Barrau, A., & Bonnabel, S. (2016). The invariant extended Kalman
% filter as a stable observer. IEEE Transactions on Automatic Control,
% 62(4), 1797-1812. 
%

%% Initialization and Simulation Parameters
% Start by cleaning the workspace.
clear all;
close all;

%% 
% We set the simulation as in [1], section IV. The robot drives along a 10
% m diameter circle for 40 seconds with high rate odometer measurements
% (100 Hz) and low rate GPS measurements (1 Hz). The vehicle gets moderate
% angular velocity uncertainty and highly precise linear velocity. The
% initial values of the heading error is 45° while the initial position is
% known.

% Monte-Carlo runs
N_mc = 5;
% sequence time (s)
T = 40; 
% odometry frequency (Hz)
odo_freq = 100; 
% odometry noise standard deviation
odo_noise_std = [0.01; % speed (v/m)
                 0.01; % speed (v/m)
                 1/180*pi]; % angular speed (rad/s)
% GPS frequency (Hz)
gps_freq = 1;
% GPS noise standard deviation (m)
gps_noise_std = 1;

% total number of timestamps
N = T*odo_freq;
% time between succesive timestamps (s)
dt = 1/odo_freq;
% radius of the circle trajectory (m)
radius = 5;

%% Filter Design
% Additionnaly to the three UKFs, we compare them to an EKF and an IEKF.
% The EKF has the same uncertainty representation as the UKF with uncertainty representation 1),
% whereas the IEKF has the same uncertainty representation as the UKF with error
% 2). As we have five similar methods, the code is redundant.

% propagation noise matrix
Q = diag(odo_noise_std.^2);

% measurement noise matrix
R = gps_noise_std^2 * eye(2);

% initial error matrix 
P0 = zeros(3, 3);
init_heading_error_std = 45/180*pi;
% we take into account initial heading error
P0(1, 1) = (init_heading_error_std)^2;
ukf_right_P0 = P0; % this is correct for your situation, see [1]
ukf_left_P0 = P0;
iekf_left_P0 = P0;

% sigma point parameter
ukf_alpha = [1e-3 1e-3 1e-3];

% define the UKF functions
ukf_f = @localization_f;
ukf_h = @localization_h;

ukf_phi = @localization_phi;
ukf_left_phi = @localization_left_phi;
ukf_right_phi = @localization_right_phi;

ukf_phi_inv = @localization_phi_inv;
ukf_left_phi_inv = @localization_left_phi_inv;
ukf_right_phi_inv = @localization_right_phi_inv;

ukf_weights = ukf_set_weight(length(P0), length(Q), ukf_alpha);
ukf_cholQ = chol(Q);

%%
% We set error variables before launching Monte-Carlo simulations
ukf_left_err = zeros(2, N_mc);
ukf_right_err = zeros(2, N_mc);
ukf_err = zeros(2, N_mc);
iekf_err = zeros(2, N_mc);
ekf_err = zeros(2, N_mc);

%% Monte-Carlo runs
% Run the Monte-Carlo loop and be patient

for n_mc = 1:N_mc
    disp("Monte-Carlo iteration(s): " + num2str(n_mc) + "/" + num2str(N_mc));
    % simulation true trajectory
    [true_state, omega] = localization_simu_f(T, odo_freq, ...
        odo_noise_std, radius);
    % simulate measurement
    [y, one_hot_y] = localization_simu_h(true_state, T, odo_freq, ...
    gps_freq, gps_noise_std);

    % initialize filter with innacurate state
    ukf_state = true_state(1);
    % we sample an initial heading error from the true distribution. This
    % is the correct manner to compare the filters but requires more
    % Monte-Carlo samples than a static values
    init_heading_error = init_heading_error_std*randn(1); 
    ukf_state.Rot = true_state(1).Rot * so2_exp(init_heading_error);
    ukf_left_state = ukf_state(1);
    ukf_right_state = ukf_state(1);
    ekf_state = ukf_state(1);
    iekf_state = ukf_state(1);
    
    ukf_P = P0;
    ukf_left_P = ukf_left_P0;
    ukf_right_P = ukf_right_P0;
    ekf_P = P0;
    iekf_P = ukf_left_P0;
    
    % variables for recording estimates of the Monte-Carlo run
    ukf_states = ukf_state;
    ukf_left_states = ukf_left_state;
    ukf_right_states = ukf_right_state;
    iekf_states = iekf_state;
    ekf_states = ekf_state;
    
    ukf_Ps = zeros(N, 3, 3);
    ukf_left_Ps = zeros(N, 3, 3);
    ukf_right_Ps = zeros(N, 3, 3);
    ekf_Ps = zeros(N, 3, 3);
    iekf_Ps = zeros(N, 3, 3);
    
    ukf_Ps(1, :, :) = ukf_P;
    ukf_left_Ps(1, :, :) = ukf_left_P;
    ukf_right_Ps(1, :, :) = ukf_right_P;
    ekf_Ps(1, :, :) = ekf_P;
    iekf_Ps(1, :, :) = iekf_P;
    
    % measurement iteration number
    k = 2;

    % filtering loop
    for n = 2:N
        % propagation
        [ukf_state, ukf_P] = ukf_propagation(ukf_state, ukf_P, omega(n-1), ...
            ukf_f, dt, ukf_phi, ukf_phi_inv, ukf_cholQ, ukf_weights);
        [ukf_left_state, ukf_left_P] = ukf_propagation(ukf_left_state, ...
            ukf_left_P, omega(n-1), ukf_f, dt, ukf_left_phi, ...
            ukf_left_phi_inv, ukf_cholQ, ukf_weights);
        [ukf_right_state, ukf_right_P] = ukf_propagation(...
            ukf_right_state, ukf_right_P, omega(n-1), ...
            ukf_f, dt, ukf_right_phi, ukf_right_phi_inv, ukf_cholQ, ...
            ukf_weights);
        [ekf_state, ekf_P] = localization_ekf_propagation(ekf_state, ...
            ekf_P, omega(n-1), dt, Q);
        [iekf_state, iekf_P] = localization_iekf_propagation(...
            iekf_state, iekf_P, omega(n-1), dt, Q);
   
        % update only if a measurement is received
        if one_hot_y(n) == 1
           [ukf_state, ukf_P] = ukf_update(ukf_state, ukf_P, ...
               y(:, k), ukf_h, ukf_phi, R, ukf_weights);
           [ukf_left_state, ukf_left_P] = ukf_update(ukf_left_state, ...
               ukf_left_P, y(:, k), ukf_h, ukf_left_phi, R, ukf_weights);           
           [ukf_right_state, ukf_right_P] = ukf_update(ukf_right_state, ...
               ukf_right_P, y(:, k), ukf_h, ukf_right_phi, ...
               R, ukf_weights);
           [ekf_state, ekf_P] = localization_ekf_update(ekf_state, ...
               ekf_P, y(:, k), R);
           [iekf_state, iekf_P] = localization_iekf_update(iekf_state, ...
               iekf_P, y(:, k), R);
            k = k + 1;
        end
        % save estimates
        ukf_states(n) = ukf_state;
        ukf_left_states(n) = ukf_left_state;
        ukf_right_states(n) = ukf_right_state;
        ekf_states(n) = ekf_state;
        iekf_states(n) = iekf_state;
        
        ukf_Ps(n, :, :) = ukf_P;
        ukf_left_Ps(n, :, :) = ukf_left_P;
        ukf_right_Ps(n, :, :) = ukf_right_P;
        ekf_Ps(n, :, :) = ekf_P;
        iekf_Ps(n, :, :) = iekf_P;
        
    end
    % record errors
    ukf_left_err(:, n_mc) = localization_error(true_state, ukf_left_states);
    ukf_right_err(:, n_mc) = localization_error(true_state, ukf_right_states);
    ukf_err(:, n_mc) = localization_error(true_state, ukf_states);
    iekf_err(:, n_mc) = localization_error(true_state, iekf_states);
    ekf_err(:, n_mc) = localization_error(true_state, ekf_states);
end

%% Results
% Simulations are ended, we can know compare the algorithms. Let us
% visualize the results for the last run. As simulations have random
% process, they just give us an indication but not a proof of filter
% performances.

benchmark_localization_helper;

%%
% More interesting is to compute results averaged over all the Monte-Carlo.
% Let us compute the Root Mean Squared Error (RMSE)for each method both for
% the orientation and the position.

disp(' ')
disp('Root Mean Square Error w.r.t. orientation (deg)');
disp("    -standard UKF: " + ukf_err_rot);
disp("    -left UKF    : " + ukf_left_err_rot);
disp("    -right UKF   : " + ukf_right_err_rot);
disp("    -EKF         : " + ekf_err_rot);
disp("    -IEKF        : " + iekf_err_rot);

disp(' ')
disp('Root Mean Square Error w.r.t. position (m)');
disp("    -standard UKF: " + ukf_err_p);
disp("    -left UKF    : " + ukf_left_err_p);
disp("    -right UKF   : " + ukf_right_err_p);
disp("    -EKF         : " + ekf_err_p);
disp("    -IEKF        : " + iekf_err_p);

%%
% Which filter is the best ? We expect it is the left UKF as it takes
% advantage of both theory of IEKF uncertainty representation and better noise
% incorporation of UKF compared to EKF. Depending on which source of error
% (sensor noise, initial condition) is the most important, it can lead to
% different results. We also note that we have set all the filters with the same
% "true" noise covariance parameters. Hovewer, both EKF and UKF based
% algorihms may better deal with non-linearity by e.g. inflated propagation
% noise covariance.

%% Conclusion
% best of iekf and UKF importance of noise and theory. Surprisingly UKF.
% Try other simulation parameters. Results can change.
% display error, other metrics

##### SOURCE END #####
--></body></html>